#  HTTP
## HTTP란?
HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다. HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며,
클라이언트-서버 프로토콜이기도 하다. 클라이언트-서버 프로토콜이란 수신자 측에 의해 요청이 초기화되는 프로토콜을 의미한다.
하나의 완전한 문서는 텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등 불러온(fatched) 하위 문서들로 재구성된다.

<br>
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/fetching-a-page.svg"
    />
</p>
<br>

클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다. 보통 브라우저인 클라이언트에 의해 전송되는 메시지를 요청(requests)이라고 부르며,
전송된 메시지를 서버에서 대응하는 것을 응답(responses)이라고 부른다.

<br>
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-layers.svg"
    />
</p>
<br>

1990년대 초에 설계된 HTTP는 여러 번의 진화를 거치며 확장 가능한 프로토콜로 발전해왔다.
HTTP는 애플리케이션 계층의 프로토콜로, 이론적으로 신뢰할 수 있는 어떤 전송 프로토콜도 사용할 수 있지만,
주로 TCP 또는 암호화된 TCP 연결인 TLS를 통해 전송된다. HTTP의 뛰어난 확장성 덕분에 오늘날에는 하이퍼텍스트 문서뿐만 아니라
이미지, 비디오 또는 HTML 폼 데이터를 서버로 전송(POST)하는 데에도 사용된다. 또한, HTTP는 웹 페이지를 동적으로 업데이트하기 위해 문서의 일부만 가져오는 데에도 활용된다.

## HTTP 기반 시스템 구성요소
HTTP는 클라이언트-서버 프로토콜이다. 요청은 하나의 개체, 사용자 에이전트(또는 프록시)에 의해 전송된다.
대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있다. 예를 들어, 검색 엔진 인덱스를 채워놓고 유지하기 위해 웹을 돌아다니는 로봇이 그러한 경우다.
<br><br>
각각의 개별적인 요청들은 서버로 보내지며, 서버는 요청을 처리하고 response라고 불리는 응답을 제공한다. 이 요청과 응답 사이에는 여러 개체들이 있는데, 예를 들면 다양한 작업을 수행하는 게이트웨이 또는 캐시 역할을 하는 프록시 등이 있다.

<br>
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/client-server-chain.svg"
    />
</p>
<br>

실제로는 브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재한다(라우터, 모뎀 등).
웹의 계층적인 설계 덕분에, 이들은 네트워크와 전송 계층 내로 숨겨진다. HTTP는 애플리케이션 계층의 최상위에 있다.
네트워크 문제를 진단하는 것도 중요하지만, 기본 레이어들은 HTTP의 명세와는 거의 관련이 없다.

## 클라이언트: 사용자 에이전트
사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구를 의미한다. 주로 웹 브라우저가 이 역할을 수행하지만, 엔지니어 또는 웹 개발자가 애플리케이션을 디버깅하기 위해 사용하는 프로그램도 사용자 에이전트 역할을 할 수 있다.
<br><br>
브라우저는 항상 요청을 시작하는 주체이다. 서버가 요청을 시작하는 일은 없지만, 서버가 메시지를 시작한 것처럼 보이게 하는 몇 가지 메커니즘이 시간이 지나면서 추가되었다.
<br><br>
웹 페이지를 표시하기 위해 브라우저는 먼저 해당 페이지를 나타내는 HTML 문서를 가져오기 위한 초기 요청을 보낸다. 그런 다음 이 파일을 해석하면서 실행 스크립트, 레이아웃 정보(CSS) 그리고 페이지 내에 포함된 하위 리소스(이미지, 비디오)에 대한 추가 요청을 생성한다.
웹 브라우저는 이렇게 수집한 리소스들을 조합하여 완전한 문서, 즉 웹 페이지를 사용자에게 표시한다. 브라우저에서 실행되는 스크립트는 이후 단계에서 추가 리소스를 가져올 수 있으며, 브라우저는 이에 따라 웹 페이지를 업데이트한다.
<br><br>
웹 페이지는 하이퍼텍스트 문서이다. 이는 표시된 콘텐츠의 일부가 링크로 구성되어 있음을 의미하며, 이러한 링크는 일반적으로 마우스 클릭으로 활성화되어 새 웹 페이지를 가져올 수 있다. 사용자는 이를 통해 사용자 에이전트를 제어하고 웹을 탐색할 수 있다. 브라우저는 사용자의 이러한 명령을 HTTP 요청으로 변환하고, HTTP 응답을 해석하여 사용자가 명확한 결과를 볼 수 있도록 한다.

## 웹 서버
통신 채널의 반대편에는 클라이언트의 요청에 따라 문서를 제공하는 서버가 있다. 서버는 가상적으로 단일 기계처럼 보이지만, 실제로는 부하 분산(load balancing)을 위해 여러 서버로 구성된 집합이거나, 요청에 따라 문서를 생성하는 캐시, 데이터베이스 서버, 전자상거래 서버 등의 소프트웨어일 수도 있다.
<br><br>
서버는 반드시 단일 기계일 필요는 없다. 동일한 기계에서 여러 서버 소프트웨어 인스턴스가 호스팅될 수 있다. HTTP/1.1과 Host 헤더를 사용하면 동일한 IP 주소를 공유할 수도 있다.

## 프록시
웹 브라우저와 서버 사이에는 HTTP 메시지를 중계하는 수많은 컴퓨터와 장치가 있다. 웹 스택의 계층적 구조 덕분에 이러한 대부분의 장치는 전송, 네트워크 또는 물리 계층에서 작동하며 HTTP 계층에서는 투명하게 작동하지만 성능에 중대한 영향을 미칠 수 있다. 애플리케이션 계층에서 작동하는 장치는 일반적으로 **프록시**라고 불린다.
<br><br>
프록시는 투명하거나(수신한 요청을 변경하지 않고 그대로 전달), 비투명(서버에 전달하기 전에 요청을 변경)할 수도 있다. 프록시는 다양한 기능을 수행할 수 있다.

- 캐싱: 캐시는 공개적일 수도 있고 브라우저 캐시처럼 개인적일 수도 있다.
- 필터링: 바이러스 검사나 자녀 보호 기능과 같은 필터링 작업을 수행한다.
- 부하 분산: 여러 서버가 서로 다른 요청을 처리하도록 분산한다.
- 인증: 다양한 리소스에 대한 접근을 제어한다.
- 로깅: 과거 정보를 저장할 수 있도록 기록한다.

## HTTP의 기본 측면
### HTTP는 간단하다.
HTTP는 일반적으로 간단하고 사람이 읽을 수 있도록 설계되었다. HTTP/2에서 HTTP 메시지를 프레임으로 캡슐화하면서 복잡성이 추가되었지만, 여전히 HTTP 메시지는 사람이 읽고 이해할 수 있다.
이는 개발자에게 더 쉬운 테스트 환경을 제공하고 초보자에게 복잡성을 줄여준다.
### HTTP는 확장 가능하다.
HTTP/1.0에서 도입된 HTTP 헤더는 이 프로토콜을 확장하고 실험하기 쉽게 만들어준다. 새로운 기능은 클라이언트와 서버 간에 새로운 헤더읭 ㅢ미에 대한 합의를 통해 도입될 수 있다.
### HTTP는 상태 유지는 안하지만, 세션은 가능하다.
HTTP는 상태를 유지하지 않는다. 즉, 동일한 연결에서 연속적으로 수행되는 두 요청 간에 연관성이 없다.
예를 들어, 전자상거래 쇼핑 장바구니와 같이 특정 페이지와 상호작용하려는 사용자에게 문제를 일으킬 수 있다.
그러나 HTTP 자체는 상태를 유지하지 않더라도, HTTP 쿠키를 사용하여 상태를 유지하는 세션을 구현할 수 있다.
헤더 확장성을 활용해 HTTP 쿠키를 워크플로우에 추가함으로써, 동일한 컨텍스트나 상태를 공유하는 세션을 HTTP 요청마다 생성할 수 있다.

## HTTP와 연결
연결은 전송 계층에서 제어되며, 기본적으로 HTTP의 범위를 벗어난다. HTTP는 기반 전송 프로토콜이 반드시 연결 기반일 필요는 없지만, 신뢰할 수 있어야 하며 메시지가 손실되지 않아야 한다(최소한의 손실 시 오류를 표시해야 한다).
인터넷에서 가장 일반적인 두 가지 전송 프로토콜 중 TCP는 신뢰할 수 있고, UDP는 그렇지 않다. 따라서 HTTP는 연결 기반인 TCP 표준에 의존한다.
<br><br>
클라이언트와 서버가 HTTP 요청/응답 쌍을 교환하려면 먼저 TCP 연결을 설정해야 하며, 이는 여러 번의 왕복이 필요하다. HTTP/1.0의 기본 동작은 각 HTTP 요청/응답 쌍마다 별도의 TCP 연결은 여는 것이며, 이는 연속적으로 여러 요청이 전송될 때 비효율적이다.
<br><br>
이 문제를 완화하기 위해 HTTP/1.1에서는 파이프라이닝과 지속적인 연결을 도입했다. 여기서 Connection 헤더를 사용하여 기본 TCP 연결을 부분적으로 제어할 수 있다. HTTP/2는 한 단계 더 나아가 단일 연결에서 메시지를 다중화하여 연결을 효율적으로 유지했다.
<br><br>
HTTP에 더 적합한 전송 프로토콜을 설계하기 위한 실험도 진행 중이다. 예를 들어, Google은 UDP를 기반으로 더 신뢰할 수 있고 효율적인 전송 프로토콜을 제공하는 QUIC를 실험 중이다.

## HTTP로 제어할 수 있는 기능
HTTP의 확장 가능한 특성 덕분에 시간이 지나면서 웹의 더 많은 제어와 기능이 가능해졌다. 캐시 및 인증 방법은 HTTP 초기에 처리된 기능이었고, 출처 제약(origin constraint)을 완화하는 기능은 2010년대에 추가되었다.
<br><br>
다음은 HTTP로 제어할 수 있는 일반적인 기능 목록이다.

- 캐싱: 문서가 어떻게 캐시될지 HTTP로 제어할 수 있다. 서버는 프록시와 클라이언트에 어떤 내용을 얼마나 오래 캐시할지 지시할 수 있으며, 클라이언트는 중간 캐시 프록시에게 저장된 문서를 무시하라고 지시할 수도 있다.
- 출처 제약 완화: 스누핑 및 기타 프라이버시 침해를 방지하기 위해 웹 브라우저는 웹사이트 간의 엄격한 분리를 시행한다. 그러나 HTTP 헤더를 통해 서버 측에서 이 제약을 완화할 수 있으며, 다양한 도메인에서 정보를 가져와 문서를 구성할 수 있다. 이는 보안 관련 이유로도 필요할 수 있다.
- 인증: 특정 사용자만 접근할 수 있도록 페이지를 보호할 수 있다. HTTP는 WWW-Authenticate와 같은 헤더를 사용하거나, HTTP 쿠키로 특정 세션을 설정하여 기본 인증을 제공한다.
- 프록시와 터널링: 서버나 클라이언트가 종종 인트라넷에 위치하여 다른 컴퓨터로부터 실제 IP주소를 숨길 수 있다. 이 경우 HTTP 요청은 프록시를 통해 네트워크 장벽을 넘어간다. 모든 프록시가 HTTP 프록시는 아니며, SOCKS 프로토콜은 더 낮은 수준에서 작동한다. FTP와 같은 다른 프로토콜도 이러한 프록시로 처리할 수 있다.
- 세션: HTTP 쿠리르 사용하면 요청을 서버의 상태와 연결할 수 있다. 이를 통해 기본적으로 상태를 유지하지 않는 HTTP에서 세션을 생성할 수 있으며, 이는 전자상거래 쇼핑 장바구니뿐만 아니라 사용자 환경 구성이 필요한 모든 사이트에서 유용하다.

## HTTP 흐름
클라이언트가 서버와 통신하고자 할 때, 최종 서버가 됐든 중간 프록시가 됐든 다음 단계의 과정을 수행한다.
<br><br>
1. TCP 연결을 연다. TCP 연결은 요청을 보내거나 응답을 받는데 사용된다. 클라이언트는 새 연결을 열거나, 기존 연결을 재사용하거나, 서버에 대한 여러 TCP 연결을 열 수 있다.
2. HTTP메시지를 전송한다. HTTP 메시지는 인간이 읽을 수 있다. HTTP/2에서는 이러한 간단한 메시지가 프레임 속으로 캡슐화되어 직접 읽는게 불가능하지만 원칙은 동일하다.
```HTTP
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```
3. 서버에 의해 전송된 응답을 읽어들인다.
```HTTP
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```
4. 연결을 닫거나 다른 요청들을 위해 재사용된다.
<br>
HTTP 파이프라이닝이 활성화되면, 첫번째 응답을 완전히 수신할 때까지 기다리지 않고 여러 요청을 보낼 수 잇다. HTTP 파이프라닝은 오래된 소프트웨어와 최신 버전이 공존하고 있는, 기존의 네트워크 상에서 구현하기 어렵다는게 입증되었으며, 프레임안에서보다 활발한 다중 요청을 보내는 HTTP/2로 교체되고 있다.

## HTTP 메시지
### 요청
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-request.svg"
    width="400"
    />
</p>
<br>

- `Method`<br>보통 클라이언트가 수행하고자 하는 동작을 정의한 `GET`, `POST` 같은 동사나 `OPTIONS`나 `HEAD`와 같은 명사이다. 일반적으로, 클라이언트는 리소스를 가져오거나 HTML 폼의 데이터를 전송하려고 하지만, 다른 경우에는 다른 동작이 요구될 수도 있다.
- `Path`<br>프로토콜, 도메인 또는 TCP 포트인 요소들을 제거한 리소스의 URL이다.
- `HTTP Protocol version`
- `Headers`

### 응답
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-response.svg"
    width="500"
    />
</p>
<br>

- `HTTP Protocol version`
- `Status code`<br>요청의 성공 여부와 이유를 나타냄
- `Status message`<br>상태를 나타냄
- `Headers`


### 참고문헌 및 이미지 출처
<p>
  <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">
    MDN WEB DOCS
  </a>
</p>
