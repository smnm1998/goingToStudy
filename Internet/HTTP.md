#  HTTP
## HTTP란?
HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다. HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며,
클라이언트-서버 프로토콜이기도 하다. 클라이언트-서버 프로토콜이란 수신자 측에 의해 요청이 초기화되는 프로토콜을 의미한다.
하나의 완전한 문서는 텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등 불러온(fatched) 하위 문서들로 재구성된다.

<br>
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/fetching-a-page.svg"
    />
</p>
<br>

클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다. 보통 브라우저인 클라이언트에 의해 전송되는 메시지를 요청(requests)이라고 부르며,
전송된 메시지를 서버에서 대응하는 것을 응답(responses)이라고 부른다.

<br>
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/http-layers.svg"
    />
</p>
<br>

1990년대 초에 설계된 HTTP는 여러 번의 진화를 거치며 확장 가능한 프로토콜로 발전해왔다.
HTTP는 애플리케이션 계층의 프로토콜로, 이론적으로 신뢰할 수 있는 어떤 전송 프로토콜도 사용할 수 있지만,
주로 TCP 또는 암호화된 TCP 연결인 TLS를 통해 전송된다. HTTP의 뛰어난 확장성 덕분에 오늘날에는 하이퍼텍스트 문서뿐만 아니라
이미지, 비디오 또는 HTML 폼 데이터를 서버로 전송(POST)하는 데에도 사용된다. 또한, HTTP는 웹 페이지를 동적으로 업데이트하기 위해 문서의 일부만 가져오는 데에도 활용된다.

## HTTP 기반 시스템 구성요소
HTTP는 클라이언트-서버 프로토콜이다. 요청은 하나의 개체, 사용자 에이전트(또는 프록시)에 의해 전송된다.
대부분의 경우, 사용자 에이전트는 브라우저지만, 무엇이든 될 수 있다. 예를 들어, 검색 엔진 인덱스를 채워놓고 유지하기 위해 웹을 돌아다니는 로봇이 그러한 경우다.
<br><br>
각각의 개별적인 요청들은 서버로 보내지며, 서버는 요청을 처리하고 response라고 불리는 응답을 제공한다. 이 요청과 응답 사이에는 여러 개체들이 있는데, 예를 들면 다양한 작업을 수행하는 게이트웨이 또는 캐시 역할을 하는 프록시 등이 있다.

<br>
<p align="center">
  <img 
    src="https://mdn.github.io/shared-assets/images/diagrams/http/overview/client-server-chain.svg"
    />
</p>
<br>

실제로는 브라우저와 요청을 처리하는 서버 사이에는 좀 더 많은 컴퓨터들이 존재한다(라우터, 모뎀 등).
웹의 계층적인 설계 덕분에, 이들은 네트워크와 전송 계층 내로 숨겨진다. HTTP는 애플리케이션 계층의 최상위에 있다.
네트워크 문제를 진단하는 것도 중요하지만, 기본 레이어들은 HTTP의 명세와는 거의 관련이 없다.

## 클라이언트: 사용자 에이전트
사용자 에이전트는 사용자를 대신하여 동작하는 모든 도구를 의미한다. 주로 웹 브라우저가 이 역할을 수행하지만, 엔지니어 또는 웹 개발자가 애플리케이션을 디버깅하기 위해 사용하는 프로그램도 사용자 에이전트 역할을 할 수 있다.
<br><br>
브라우저는 항상 요청을 시작하는 주체이다. 서버가 요청을 시작하는 일은 없지만, 서버가 메시지를 시작한 것처럼 보이게 하는 몇 가지 메커니즘이 시간이 지나면서 추가되었다.
<br><br>
웹 페이지를 표시하기 위해 브라우저는 먼저 해당 페이지를 나타내는 HTML 문서를 가져오기 위한 초기 요청을 보낸다. 그런 다음 이 파일을 해석하면서 실행 스크립트, 레이아웃 정보(CSS) 그리고 페이지 내에 포함된 하위 리소스(이미지, 비디오)에 대한 추가 요청을 생성한다.
웹 브라우저는 이렇게 수집한 리소스들을 조합하여 완전한 문서, 즉 웹 페이지를 사용자에게 표시한다. 브라우저에서 실행되는 스크립트는 이후 단계에서 추가 리소스를 가져올 수 있으며, 브라우저는 이에 따라 웹 페이지를 업데이트한다.
<br><br>
웹 페이지는 하이퍼텍스트 문서이다. 이는 표시된 콘텐츠의 일부가 링크로 구성되어 있음을 의미하며, 이러한 링크는 일반적으로 마우스 클릭으로 활성화되어 새 웹 페이지를 가져올 수 있다. 사용자는 이를 통해 사용자 에이전트를 제어하고 웹을 탐색할 수 있다. 브라우저는 사용자의 이러한 명령을 HTTP 요청으로 변환하고, HTTP 응답을 해석하여 사용자가 명확한 결과를 볼 수 있도록 한다.

## 웹 서버
통신 채널의 반대편에는 클라이언트의 요청에 따라 문서를 제공하는 서버가 있다. 서버는 가상적으로 단일 기계처럼 보이지만, 실제로는 부하 분산(load balancing)을 위해 여러 서버로 구성된 집합이거나, 요청에 따라 문서를 생성하는 캐시, 데이터베이스 서버, 전자상거래 서버 등의 소프트웨어일 수도 있다.
<br><br>
서버는 반드시 단일 기계일 필요는 없다. 동일한 기계에서 여러 서버 소프트웨어 인스턴스가 호스팅될 수 있다. HTTP/1.1과 Host 헤더를 사용하면 동일한 IP 주소를 공유할 수도 있다.

## 프록시
웹 브라우저와 서버 사이에는 HTTP 메시지를 중계하는 수많은 컴퓨터와 장치가 있다. 웹 스택의 계층적 구조 덕분에 이러한 대부분의 장치는 전송, 네트워크 또는 물리 계층에서 작동하며 HTTP 계층에서는 투명하게 작동하지만 성능에 중대한 영향을 미칠 수 있다. 애플리케이션 계층에서 작동하는 장치는 일반적으로 **프록시**라고 불린다.
<br><br>
프록시는 투명하거나(수신한 요청을 변경하지 않고 그대로 전달), 비투명(서버에 전달하기 전에 요청을 변경)할 수도 있다. 프록시는 다양한 기능을 수행할 수 있다.

- 캐싱: 캐시는 공개적일 수도 있고 브라우저 캐시처럼 개인적일 수도 있다.
- 필터링: 바이러스 검사나 자녀 보호 기능과 같은 필터링 작업을 수행한다.
- 부하 분산: 여러 서버가 서로 다른 요청을 처리하도록 분산한다.
- 인증: 다양한 리소스에 대한 접근을 제어한다.
- 로깅: 과거 정보를 저장할 수 있도록 기록한다.

## HTTP의 기본 측면
### HTTP는 간단하다.
HTTP는 일반적으로 간단하고 사람이 읽을 수 있도록 설계되었다. HTTP/2에서 HTTP 메시지를 프레임으로 캡슐화하면서 복잡성이 추가되었지만, 여전히 HTTP 메시지는 사람이 읽고 이해할 수 있다.
이는 개발자에게 더 쉬운 테스트 환경을 제공하고 초보자에게 복잡성을 줄여준다.
### HTTP는 확장 가능하다.
HTTP/1.0에서 도입된 HTTP 헤더는 이 프로토콜을 확장하고 실험하기 쉽게 만들어준다. 새로운 기능은 클라이언트와 서버 간에 새로운 헤더읭 ㅢ미에 대한 합의를 통해 도입될 수 있다.
### HTTP는 상태 유지는 안하지만, 세션은 가능하다.
HTTP는 상태를 유지하지 않는다. 즉, 동일한 연결에서 연속적으로 수행되는 두 요청 간에 연관성이 없다.
예를 들어, 전자상거래 쇼핑 장바구니와 같이 특정 페이지와 상호작용하려는 사용자에게 문제를 일으킬 수 있다.
그러나 HTTP 자체는 상태를 유지하지 않더라도, HTTP 쿠키를 사용하여 상태를 유지하는 세션을 구현할 수 있다.
헤더 확장성을 활용해 HTTP 쿠키를 워크플로우에 추가함으로써, 동일한 컨텍스트나 상태를 공유하는 세션을 HTTP 요청마다 생성할 수 있다.

### 참고문헌 및 이미지 출처
<p>
  <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">
    MDN WEB DOCS
  </a>
</p>
