# 웹 성능 향상을 위한 브라우저 작동 원리
## 개요
빠른 사이트는 더 나은 사용자 경험을 제공한다. 사용자들은 콘텐츠 로드가 빠르고 상호작용이 원활한 웹 경험을 기대하고 요구한다. 웹 성능에서 주요한 두 가지 문제는 **지연**과 브라우저가 대부분 **단일 스레드**라는 점이다.

- **지연**<br>
지연은 페이지의 빠른 로드를 방해하는 가장 큰 위협 요소이다. 개발자의 목표는 사이트를 가능한 빠르게 로드하거나, 최소한 매우 빠르게 로드되는 것 처럼 보이게 만들어 사용자가 요청한 정보를 신속히 얻을 수 있도록 하는 것이다. 네트워크 지연이란 데이터를 컴퓨터로 전송하는 데 걸리는 시간을 말한다. 웹 성능은 페이지를 가능한 한 빠르게 로드하도록 최적화하는 데 초점을 맞춘다.
- **단일 스레드 브라우저**<br>
브라우저는 대체로 단일 스레드로 작동한다고 간주한다. 즉, 하나의 작업을 처음부터 끝까지 실행한 뒤에야 다른 작업을 수행한다. 매끄러운 상호작용을 위해 개발자는 스크롤의 부드러움에서부터 터치에 대한 반응성까지 사이트의 상호작용 성능을 보장해야 한다. **렌더링 시간**이 핵심이며, 메인 스레드가 할당된 모든 작업을 완수하면서도 항상 사용자 상호작용을 처리할 수 있도록 여유를 유지해야 한다.

웹 성능은 브라우저가 단일 스레드로 작동한다는 점을 이해하고, 가능한 한 메인 스레드의 작업 부담을 줄이는 방법으로 개선할 수 있다. 이를 통해 렌더링이 매끄럽게 이루어지고, 사용자 상호작용에 즉각적으로 반응할 수 있다.

## 네비게이션
네비게이션은 웹 페이지 로드의 첫 단계이다. 사용자가 주소창에 URL을 입력하거나, 링크를 클릭하거나, 폼을 제출하는 등의 행동을 통해 페이지를 요청할 때마다 발생한다.<br>
웹 성능의 목표 중 하나는 네비게이션이 완료되는 데 걸리는 시간을 최소화하는 것이다. 이상적인 조건에서는 네비게이션이 오래 걸리지 않지만, **지연**과 **대역폭**은 이러한 과정을 지연시킬 수 있는 주요 장애 요소이다.

### DNS 조회
웹 페이지로 이동하는 첫 번째 단계는 해당 페이지의 리소스가 어디에 위치하는지를 찾는 것이다. 예를 들어, `https://example.com`에 접속하려면 해당 HTML 페이지는 IP 주소가 `93.184.216.34`인 서버에 위치한다. 만약 이 사이트를 처음 방문하는 경우, DNS 조회가 필요하다.<br><br>
브라우저는 DNS 조회를 요청하며, 이 요청은 결국 네임 서버에 의해 처리되고, 네임 서버는 해당하는 IP 주소로 응답한다. 초기 요청 이후에는 해당 IP 주소가 일정 시간 동안 캐싱되며, 이를 통해 이후 요청 시 네임 서버에 다시 접근하지 않고 캐시에서 IP 주소를 가져와 속도를 높일 수 있다.<br><br>
DNS 조회는 일반적으로 페이지 로드 중 **호스트 이름당 한 번만 수행**된다. 그러나 요청된 페이지가 참조하는 모든 고유한 호스트 이름마다 DNS 조회가 필요하다. 예를 들어, **폰트, 이미지, 스크립트, 광고, 매트릭** 등이 서로 다른 호스트 이름을 가진 경우, 각 항목에 대해 별도의 DNS 조회가 필요하다.

<br>
<p align="center">
  <img 
    src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/latency.jpg"
    width="500"
    />
</p>
<br>

이러한 과정은 특히 모바일 네트워크에서 성능 문제를 유발할 수 있다. 사용자가 모바일 네트워크를 사용할 경우, 각 DNS 조회가 **휴대폰 → 기지국 → 권한 있는 DNS 서버**로 이동해야 한다. 이 과정에서 휴대폰, 기지국, 네임 서버 간의 거리가 상당한 지연(latency)을 추가할 수 있다.

### TCP 핸드셰이크
IP 주소가 확인되면 브라우저는 서버와 **TCP 3방향 핸드셰이크**를 통해 연결을 설정한다. 이 메커니즘은 통신을 시도하는 두 엔터티(이 경우 브라우저와 웹 서버)가 네트워크 TCP 소켓 연결의 매개변수를 협상하고 데이터를 전송하기 전에 이를 설정할 수 있도록 설계되었다. 이 과정은 종종 HTTPS를 통해 이루어진다.
<br><br>
TCP의 3방향 핸드셰이크는 흔히 **"SYN-SYN-ACK"** 또는 더 정확히는 **SYN, SYN-ACK, ACK**로 불린다. 이는 TCP가 두 컴퓨터 간의 TCP 세션을 협상하고 시작하기 위해 전송하는 세 개의 메시지를 나타낸다. 네, 이는 서버와 클라이언트 간에 세 번의 메시지가 왕복되어야 하며, 아직 콘텐츠 요청은 시작되지 않은 상태를 의미한다.

### TLS 협상
HTTPS를 통해 설정된 보안 연결의 경우 또 다른 "핸드셰이크", 즉 TLS 협상이 필요하다. 이 과정은 다음과 같다.

1. 암호화에 사용할 **암호화 알고리즘(ciphers)** 을 결정
2. **서버 검증**
3. 데이터 전송 전, **보안 연결** 설정을 확인

<br>
<p align="center">
  <img 
    src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/ssl.jpg"
    width="500"
    />
</p>
<br>

이 과정에서는 서버와의 추가적인 **5번의 왕복**이 필요하며, 이 단계가 완료된 후에야 실제 콘텐츠 요청이 전송된다.
<br><br>
보안 연결을 설정하는 데 시간이 더 걸리지만, 브라우저와 웹 서버 간에 전송되는 데이터가 제3자에 의해 복호화되지 않도록 보호되기 때문에 이 지연(latency)은 충분히 가치 있는 과정이다.

## 응답(Response)
서버와의 연결이 설정되면, 브라우저는 사용자를 대신해 첫 번째 HTTP GET 요청을 보낸다. 웹사이트의 경우, 이 요청은 가장 자주 HTML 파일을 대상으로 한다. 서버가 요청을 받으면, 관련된 응답 헤더와 함께 HTML 콘텐츠를 반환한다.<br>
다음은 예제 HTML 코드이다.

```HTML
<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title>My simple page</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="myscript.js"></script>
  </head>
  <body>
    <h1 class="heading">My Page</h1>
    <p>A paragraph with a <a href="https://example.com/about">link</a></p>
    <div>
      <img src="my-image.jpg" alt="image description" />
    </div>
    <script src="another-script.js"></script>
  </body>
</html>
```

이 초기 요청에 대한 응답에는 **TTFB(Time To First Byte)** 의 데이터가 포함되어 있다. TTFB는 사용자가 요청을 보낸 순간부터 첫 번째 HTML 데이터 패킷을 수신하는 데 걸리는 시간을 측정한다.<br><br>
이 초기 응답은 보통 14KB의 데이터로 이루어지며, 여기에는 HTML 콘텐츠의 첫 번째 부분이 포함된다. 위 예제에서, HTML 요청은 14KB보다 작지만, HTML 내에 링크된 리소스는 브라우저가 파싱 중 해당 링크를 발견할 때 까지 요청되지 않는다.

### 혼잡 제어와 TCP 슬로우 스타트
#### TCP 전송 방식
- **패킷 분할** <br>
TCP는 데이터를 전송할 때 **세그먼트** 단위로 나눈다. 각 세그먼트는 수신자(클라이언트)로 부터 **ACK(확인 응답)** 패킷을 받아야 전송이 완료된다.
- **확인 응답(ACK)**
  - 서버가 세그먼트를 하나 보낼 때마다 ACK를 기다리면 ACK가 지나치게 자주 발생해 전송 시간이 길어질 수 있다.
  - 반대로 한 번에 너무 많은 세그먼트를 보내면 네트워크가 혼잡해져 클라이언트가 세그먼트를 받을 수 없게 되고, 클라이언트는 ACK를 보내지 못하거나 지연된 ACK를 보낼 가능성이 커진다.

#### TCP 슬로우 스타트
TCP는 위와 같은 문제를 해결하기 위해 **슬로우 스타트 알고리즘**을 사용한다. 이는 전송 데이터를 점진적으로 늘려 네트워크 대역폭을 측정하고, 네트워크가 혼잡할 경우 전송량을 줄이는 방식이다.

#### 혼잡 윈도우(CWND)
혼잡 윈도우 값으로 전송할 세그먼트의 수를 조절한다.
- CWND 초기값은 1, 2, 4 또는 10 MSS(Maximum Segment Size, 이더넷 기준으로 1500바이트)로 설정
- 이 값은 클라이언트가 ACK를 보내기 전에 서버가 보낼 수 있는 데이터 양을 결정

#### 작동 방식
1. **ACK 수신 시**
   - 클라이언트로부터 ACK를 받으면 CWND 값이 두 배로 증가
   - 다음 전송에서 서버는 더 많은 세그먼트를 보낼 수 있음
2. **ACK 미수신 시**
   - ACK가 도착하지 않으면 CWND 값이 절반으로 감소
   - 이를 통해 혼잡 상태에서 전송량을 줄이고 네트워크 과부하를 방지

TCP 슬로우 스타트는 **너무 많은 세그먼트를 보내거나, 너무 적은 세그먼트를 보내는 문제를 균형 있게 해결**하여 효율적인 데이터 전송을 보장한다.

## 파싱(Parsing)
브라우저가 첫 데이터 청크(chunk)를 수신하면, 이를 **파싱(parsing)** 하는 과정을 통해 받은 데이터를 화면에 표시할 준비를 시작한다.
### 파싱이란?
파싱은 네트워크를 통해 받은 데이터를 브라우저가 **DOM(Document Object Model)** 및 **CSSOM(CSS Object Model)** 으로 변환하는 단계이다.

- **DOM**
  - HTML 마크업의 내부 표현으로, 브라우저가 이를 기반으로 웹 페이지를 렌더링
  - DOM은 JavaScript API를 통해 노출되며, 조작할 수 있다.
- **CSSOM**
  - CSS 스타일 정보를 모델로 변환하여 DOM과 함께 사용된다.
 
### 파싱과 초기 렌더링
- 브라우저는 요청한 HTML 파일의 크기가 초기 14KB 패킷보다 커도, 수신된 데이터를 기반으로 파싱을 시작
- **웹 성능 최적화**에서는 초기 14KB 내에 페이지 렌더링에 필요한 핵심 요소(HTML, CSS, JavaScript의 기본 템플릿)를 포함시키는 것이 중요하다.
  - 초기 렌더링을 위한 CSS와 HTML을 빠르게 제공하면, 사용자가 더 빨리 콘텐츠를 확인할 수 있다.

### 렌더링 이전 과정
- HTML, CSS, JavaScript는 화면에 렌더링되기 전에 반드시 파싱되어야 한다.
- 파싱 단계에서 DOM과 CSSOM이 생성되며, 이를 기반으로 브라우저의 렌더링 엔진이 페이지를 화면에 그린다.

### DOM 트리 생성
DOM 트리 생성은 **크리티컬 렌더링 경로(Critical Rendering Path)**의 첫 번째 단계로, HTML 마크업을 처리하여 DOM 트리를 구축하는 과정이다.

#### DOM 트리 생성 과정
1. **HTML 토큰화 및 트리 구성**
   - HTML 파싱은 토큰화(tokenization) 및 **트리 구성(tree construction)** 을 포함
   - HTML 토큰: 시작 태그, 종료 태그, 속성 이름 및 속성 값
   - 문서가 잘 작성되었다면 파싱이 간단하고 빠름
   - HTML 파서는 토큰화된 입력을 문서 트리에 추가하면서 DOM 트리를 구성
   - DOM 트리의 첫 번째 루트 노드는 `<html>` 요소이며, 이는 문서의 계층 구조를 반영
2. **DOM 트리의 노드 수**
  - DOM 노드 수가 많을수록 DOM 트리 생성 시간이 증가
  - 요소들이 중첩될수록 자식 노드가 더 많아지며 트리의 복잡도가 증가

<br>
<p align="center">
  <img 
    src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/dom.gif"
    width="400"
    />
</p>
<br>

#### 비차단 리소스 처리
- 파서가 비차단 리소스(예: 이미지)를 만나면, 브라우저는 리소스를 요청한 뒤 HTML 파싱을 계속 진행
- CSS 파일을 만나면 파싱이 계속될 수 있지만, `<script>` 요소는 HTML 파싱과 렌더링을 차단
  - `async` 또는 `defer` 속성이 없는 스크립트는 차단 문제를 일으킬 수 있다.

### 프리로드 스캐너(Preload Scanner)
- DOM 트리 생성 중, 메인 스레드가 점유된 동안 **프리로드 스캐너**가 작동하여 중요한 리소스(CSS, JavaScript, 웹 폰트 등)를 미리 요청한다.
- 이를 통해 HTML 파서가 외부 리소스를 참조하기 전에 리소스를 다운로드하거나 요청 중 상태로 만들 수 있다.
```HTML
<link rel="stylesheet" href="styles.css" />
<script src="my-script.js" async></script>
<img src="my-image.jpg" alt="image description" />
<script src="another-script.js" async></script>
```
- 메인 스레드가 HTML과 CSS를 파싱하는 동안, 프리로드 스캐너는 스크립트와 이미지를 찾아 다운로드를 시작
- 스크립트가 프로세스를 차단하지 않도록 하려면 async 또는 defer 속성을 추가해야 한다.

#### CSS와 JavaScript의 상호작용
- CSS를 얻는 작업은 HTML 파싱이나 다운로드를 차단하지 않지만, JavaScript 실행을 차단할 수 있다.
- 이는 JavaScript가 CSS 속성을 기반으로 동작하는 경우가 많기 때문

### CSSOM 트리 생성
**크리티컬 렌더링 경로**의 두 번째 단계는 CSS를 처리하여 **CSSOM 트리**를 생성하는 것이다.

#### CSSOM 트리 생성 과정
1. **CSS 규칙 파싱**
   - 브라우저는 CSS 규칙을 처리하여 이해 가능한 스타일 맵으로 변환
   - CSS 선택자를 기반으로 부모-자식-형제 관계를 가진 노드 트리를 만듦
2. **스타일 적용**
   - 사용자 에이전트 스타일 시트로 시작해, 각 노드에 적용 가능한 가장 일반적인 규칙을 시작으로 점차 구체적인 규칙을 적용
   - 이 과정에서 CSS 속성 값은 **계단식(Cascade)** 으로 계산됨

#### CSSOM 생성 속도
- CSSOM 트리 생성은 매우 빠름
- 개발자 도구의 **Recalculate Style**은 CSS 파싱, CSSOM 트리 생성, 계산된 스타일 재귀적 계산 시간을 모두 포함한 총 시간을 보여줌
- **웹 성능 최적화에서 CSSOM 트리 생성에 많은 시간을 투자할 필요는 없다.** 왜냐하면 CSSOM 생성 시간은 일반적으로 DNS 조회 시간보다도 짧기 때문

## 렌더(Render)
렌더링 과정은 스타일 적용, 레이아웃, 페인트, 그리고 경우에 따라 컴포지팅을 포함한다. 파싱 단계에서 생성된 CSSOM과 DOM 트리는 렌더 트리로 결합되어 각 가시적인 요소의 레이아웃이 계산되며, 최종적으로 화면에 렌더링된다. 일부 콘텐츠는 별도의 레이어로 승격되어 GPU에서 페인트되기도 하며, 이는 성능을 향상시키고 메인 스레드를 해방시킨다.

### Style: Render Tree 생성
렌더링 경로의 세 번째 단계는 DOM과 CSSOM을 결합하여 **렌더 트리(render tree)** 를 생성하는 것이다.

#### 렌더 트리 생성 과정
1. **렌더 트리에 포함되지 않는 요소**
  - `<head>`와 같이 화면에 표시되지 않는 요소, 또는 `display: none` 속성을 가진 요소는 렌더 트리에 포함되지 않는다.
  - `visibility: hidden` 속성을 가진 요소는 화면에는 보이지 않지만 공간을 차지하기 때문에 렌더 트리에 포함
2. **CSSOM 규칙 적용**
  - DOM 트리의 각 가시적인 노드에 CSSOM의 규칙을 적용하여, 내용과 계산된 스타일(computed styles)을 포함한 렌더 트리를 생성
  - CSS 계단식 규칙(CSS Cascade)을 기반으로 각 노드의 최종 스타일을 결정

### Layout: 노드의 크기와 위치 계산
렌더링 경로의 네 번째 단계는 렌더 트리를 기반으로 **레이아웃(layout)** 을 실행하여 각 노드의 크기와 위치를 계산하는 것이다.

#### 레이아웃 과정
1. **초기 레이아웃**
   - 렌더 트리는 어떤 노드가 표시되고, 그 노드의 계산된 스타일이 무엇인지를 나타낸다. 하지만 노드의 정확한 크기와 위치는 이 과정에서 결정
   - 브라우저는 렌더 트리의 루트부터 시작해 각 노드의 박스(box) 모델 속성을 고려하여 뷰포트 크기에 맞게 배치
2. **리플로우(Reflow)**
   - 리플로우는 페이지의 일부 또는 전체 레이아웃을 다시 계산하는 작업
   - 예를 들어, 이미지 크기를 명시하지 않은 경우, 초기 레이아웃에서 임시 공간만 할당한다. 이후 이미지가 로드되면 리플로우가 발생하여 새 크기에 맞게 레이아웃이 조정된다.
  
### Paint: 화면에 그리기
렌더링 경로의 마지막 단계는 각 노드를 화면에 페인트(paint)하는 것이다.

#### 페인트 과정
1. **첫 번째 의미 있는 페인트(First Meaningful Paint)**
   - 레이아웃 단계에서 계산된 각 박스를 화면의 픽셀로 변환
   - 텍스트, 색상, 테두리, 그림자, 이미지 등 요소의 모든 시각적 부분이 그려짐
2. **레이어 분할**
   - 성능을 향상시키기 위해 레이아웃 트리의 요소를 여러 레이어로 나누어 그림
   - 특정 속성(`opacity`, `3D transform`, `will-change` 등)을 가진 요소는 GPU에서 별도의 레이어로 처리됨
   - 레이어는 성능을 향상시키지만 메모리 사용량이 증가하므로 과도한 사용은 피해야 함

### Compositing: 올바른 순서로 화면에 배치
#### 컴포지팅이 필요한 경우
- 문서의 일부가 여러 레이어로 나뉘어 그려지는 경우, 올바른 순서로 배치하기 위해 **컴포지팅(compositing)** 이 필요함
- 컴포지팅은 레이어 간의 순서를 조정하여 화면에 콘텐츠를 올바르게 표시

#### Reflow, Repaint, Re-composite
- **리플로우**: 레이아웃 단계의 재계산이 필요할 때 발생
- **리페인트**: 화면의 일부만 다시 그려야 할 때 발생
- **재컴포지팅**: 변경된 레이어를 다시 조합해야 할 때 발생

## 상호작용성과 상호작용 시간 (TTI)
브라우저가 페이지를 페인팅하는 작업을 마쳤다면, 페이지가 완전히 준비된 것처럼 보일 수 있다.<br><br>
그러나 중요한 요소가 있다. 바로 **JavaScript 실행**이다. JavaScript가 올바르게 지연되어 onload 이벤트 후에 실행되더라도 메인 스레드가 여전히 바쁘다면 페이지가 스크롤이나 터치와 같은 사용자 상호작용에 반응하지 않을 수 있다.

### 상호작용 시간 (TTI)
**TTI**는 첫 요청(여기에는 DNS 조회와 TCP 연결 포함)부터 페이지가 완전히 상호작용할 수 있는 상태가 될 때까지 걸리는 시간을 측정한다. 이는 **첫 콘텐츠 페인트(FCP)** 이후로, 페이지가 사용자 상호작용에 **50ms** 이내로 반응하는 시점을 의미한다.
<br><br>
JavaScript가 메인 스레드에서 실행 중일 경우 상호작용이 지연될 수 있습니다. 메인 스레드가 스크립트를 파싱하고 컴파일하며 실행 중이라면, 사용자 입력을 즉시 처리할 수 없어서 사용자 경험이 나빠진다.
#### 예시
만약 이미지가 빨리 로드되었지만, another-script.js 파일이 2MB이고 사용자의 네트워크 연결이 느리다면, 사용자는 페이지를 매우 빠르게 볼 수 있지만, 스크롤을 하거나 다른 상호작용을 할 수 없게 된다. 이는 좋은 사용자 경험이 아니다. 메인 스레드를 차지하지 않도록 하는 것이 중요하다.

<br>
<p align="center">
  <img 
    src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/visa_network.png"
    width="600"
    />
</p>
<br>

이 예제에서 JavaScript 실행은 1.5초 이상 걸렸고, 메인 스레드는 클릭 이벤트나 화면 탭에 반응하지 않고 그 시간 내내 완전히 사용되었다.

### 참고문헌 및 이미지 출처
<p>
  <a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#parsing">
    MDN WEB DOCS
  </a>
</p>
